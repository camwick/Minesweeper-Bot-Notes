# Meeting 10/28/2021

## Things Discussed:

- Github Commands
- File Overview
- branches
  - `boardState` branch
  - `initiateBoard` branch
- [Java 16 Robot Class](https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Robot.html)
- Minesweeper Basics

## Github Commands 

Here are the ones we discussed:
- `git status`
  - Displays the status of all the files in the directory

- `git add fileName` and `git add .`
  - Stages the files to be commited

- `git commit -m "message"`
  - Commits stages with specified message

- `git push -u origin main`
  - pushes commits made on the local repository to the main branch of the remote repository
  - `origin` can be different dependning on the repository
  - `main` can be any branch you're wanting to push

Ask any questions you have in the discord and we'll address them when they occur. I'll provide directions to specific commands whenever we are developing.

## File Overview

The github currently has three files. I just uploaded these so that we have a starting point to work on. I don't expect any code I've written to actually stay within the files when we start development. 

`Solver.java`:
- will ultimately be where all the actually *solving* of the minesweeper board occurs
- currently has nothing in it besides a main method with a board object in it
- we can either use this file as the main *driver* file or create a `Main.java`/`Driver.java` file for running our program

`Board.java`:
- will instantiate a board object
- houses information important to the minesweeper board
- a `board` object will define multipe `Cell` objects

`Cell.java`:
- will instantiate cell objects 
- houses information imortant to the individual cells (like contents, clicked/unclicked, etc...)

There are currently two additional files on the remote repository as well: `README.md` and `.gitignore`. The `README.md` is where I'll post resources that we end up using. The `.gitignore` tells git/github to ignore specific files when commiting. I've set it up to ignore `*.javac` and `*.cmd` files for now. This ignores all the class files generated by using the `javac` command and the batch files I personally use to run my programs. I will share my batch files with you guys whenever we start development to allow easy use of compiling and running.

I'll also be creating a folder to house all these notes I create so that we have access to these wherever.

## Branches

Branches are what allow us to maintain our code base. Keeping all our working code in the `main` branch will hopefully minimize the amount of bugs we come across. I've created two branches: `boardState` and `initiateBoard`. These will be the first two aspects of the Minesweeper Bot that we create. We'll split into two groups and develop these two branches so that we can merge them to `main` and continue work on the bot.

### `boardState`:
The `boardState` branch will be where one team writes the code to read the game board off the screen. 
There are a few tasks when it comes to doing this:
- finding the bounds of the game board
- defining cell bounds
- getting cell contents by using pixel `Color`
- create an output string to give to the team working on `initiateBoard`

We seem to be in agreement that using a `String` as the output/input would work best ... but we can always change this if we think there is a better solution. We can use one character for each item on the board.
- 'E' - empty cell
- 'U' - unclicked/unknown cell
- 'M' - Mine
- '*digit 1-9*' - digit corrosponding to cell number
- *more may be needed, idek*

Example:
![easy board partially solved](https://i.imgur.com/RsaqbiO.png)
We should output the String `EEEE1UUUUEEE12UUUUEEE1M22UUEEE112MUUEEEEE13UUEEEEEE1UUE111EE122E2M2111EEE2M21M1EE`.
Formatted a bit differently to help see the bigger picture:
```
    0   1   2   3   4   5   6   7   8
  -------------------------------------
0 | E | E | E | E | 1 | U | U | U | U |
  -------------------------------------
1 | E | E | E | 1 | 2 | U | U | U | U |
  -------------------------------------
2 | E | E | E | 1 | M | 2 | 2 | U | U |
  -------------------------------------
3 | E | E | E | 1 | 1 | 2 | M | U | U |
  -------------------------------------
4 | E | E | E | E | E | 1 | 3 | U | U |
  -------------------------------------
5 | E | E | E | E | E | E | 1 | U | U |
  -------------------------------------
6 | E | 1 | 1 | 1 | E | E | 1 | 2 | 2 |
  -------------------------------------
7 | E | 2 | M | 2 | 1 | 1 | 1 | E | E |
  -------------------------------------
8 | E | 2 | M | 2 | 1 | M | 1 | E | E |
  -------------------------------------
```

### `initiateBoard`:
Using the `String` as input, we can generate our `board` object with the appropriate `Cell`s. Since Easy, Intermediate, Expert, and Evil boards are always the same width, height, and mine count, we should be able to solve all board difficulties right off the bat. Either by using user input to get the difficulty level or maybe we can implement it within the `boardState` branch, we can create a `board` object to initiate an array of `Cell` objects. This array can either be one or two dimensional. Two dimensions may be easier for us to work with, but working with a one-dimensional array should prove to be the same difficulty. We can decide how we implement our `Cell` objects whenever development starts, it shouldn't be a big deal. The `Cell` objects should link to their adjacent `Cell`s in order for us to better recognize patterns. Looking back at the example in `boardState`, `Cell` (0, 0) should link to `Cell`s (1, 0), (1, 1), and (0, 1). Some basic math should help in determining which cells to link together to handle the edge cases (corners and edges). 

Right off the bat, it looks like whoever works on this branch will have an easier time, but we'll need to constantly be adding stuff to the `Board.java` and `Cell.java` files in regards to the constructors and public/private variables. At first, it only looks like `Cell` objects only need to know what is in the each `Cell` and have a link to adjacent `Cell`s, but later we might want boolean values representing if a `Cell` has been clicked or has a mine.

## [Java 16 Robot Class](https://docs.oracle.com/en/java/javase/16/docs/api/java.desktop/java/awt/Robot.html)

The `Robot Class` allows for manipulation of mouse and keyboard. It also lets us grab `Color` objects from the screen. The methods in this class will be the main meat and potatoes of this program. Using the `getPixelColor(int x, int y)` method returns a `Color` object of the pixel it was specified to read from. This will come in handy for the `boardState` branch.

When we get to the point where we want to control the mouse input, methods like `mouseMove​(int x, int y)`, `mousePress​(int buttons)`, `mouseRelease​(int buttons)` will prove very useful!

During the meeting I showed how to define a `Robot` object. The constructor throws an `AWTException` if the platform configuration doesn't allow the program to do low-level input. Because of this, we have to wrap our `Robot` initiation within a `try{}catch(){}` to handle the exception if it gets thrown.
```java
import java.awt.Robot;
import java.awt.AWTException
// notice, because we aren't importing the entire awt package, we must import the AWTException.

public static void main(String[] args){
  try{
    Robot bot = new Robot();

    // we can continue writing code within this try block
    // if the AWTException error does it thrown, the rest of this code will not run
  }
  catch(AWTException e){
    // here is where we handle if the exception gets thrown.
    // we'll probably want to stop the program from running at this point, but I'll just print the error for this example.
    System.out.println(e);
  }

  // putting code outside of the try catch block will still run as long as we don't 
  // do anything within the catch block that ends or halts the program
}

```
I'll provide more examples of the `Robot` class soon :)

## Minesweeper Basics

I played through a little bit of a Minesweeper game to help show how the game is played and how important the patterns come into play. A lot of of the board can be solved through intuition, but memorizing the patterns makes the game a whole lot easier. We should be able to implement pattern recognition into our program to increase our solve rates. Without knowledge of the most basic patterns, having our program solve a board completely will prove to be difficult. Humans can use their brain power to make educated guesses or deduce the correct move, but our Minesweeper Bot will only do what we program it to do. This is why the patterns are so important.

I highly reccoment going over some of the [basic mine patterns](https://minesweeper.online/help/patterns) and playing a little bit of the game yourself. Understanding how to play the game will make thinking of some of the logic puzzles easier ... plus it's a fun game!
 

